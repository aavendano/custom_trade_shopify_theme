const { src, dest, watch, parallel, series } = require('gulp');
const sass = require('gulp-sass')(require('sass'));
const purgecss = require('gulp-purgecss');
const rename = require('gulp-rename');
const replace = require('gulp-replace');
const gulpif = require('gulp-if');
const through2 = require('through2');
const fs = require('fs');
const path = require('path');

// Configuration
const INLINE_BYTE_LIMIT = process.env.BULMA_INLINE_LIMIT ? parseInt(process.env.BULMA_INLINE_LIMIT) : 220 * 1024;
const DISABLE_PURGE = process.env.BULMA_DISABLE_NAMESPACE_PURGE && process.env.BULMA_DISABLE_NAMESPACE_PURGE !== '0';

const paths = {
  styles: {
    critical: 'styles/bulma-critical.scss',
    async: 'styles/bulma-async.scss',
    watch: 'styles/**/*.scss'
  },
  output: {
    assets: 'assets',
    snippets: 'snippets'
  },
  content: [
    'layout/**/*.liquid',
    'sections/**/*.liquid', 
    'snippets/**/*.liquid',
    'templates/**/*.liquid',
    'templates/**/*.json',
    'blocks/**/*.liquid',
    'assets/**/*.js',
    'assets/**/*.ts'
  ]
};

// Load namespace safelist
function loadSafelist() {
  const safelistPath = process.env.BULMA_NAMESPACE_SAFELIST || 'config/namespace-safelist.json';
  try {
    const data = JSON.parse(fs.readFileSync(safelistPath, 'utf8'));
    return Array.isArray(data) ? data : [];
  } catch {
    return [];
  }
}

// PurgeCSS configuration
const purgeConfig = {
  content: paths.content,
  defaultExtractor: content => content.match(/\b(b-[A-Za-z0-9_-]+)/g) || [],
  safelist: {
    standard: ['html', 'body', ...loadSafelist()],
    greedy: [/^(?!.*\bb-).*/]
  }
};

// Sass configuration
const sassConfig = {
  outputStyle: 'compressed',
  includePaths: ['node_modules']
};

// Create inline snippet transform
function createInlineSnippet() {
  return through2.obj(function(file, enc, cb) {
    if (file.isNull()) return cb(null, file);
    
    let css = file.contents.toString();
    let trailingMarkup = '';
    
    // Handle size limit
    if (css.length > INLINE_BYTE_LIMIT) {
      const safeCutoff = css.lastIndexOf('}', INLINE_BYTE_LIMIT);
      const cutoffIndex = safeCutoff === -1 ? INLINE_BYTE_LIMIT : safeCutoff + 1;
      css = css.slice(0, cutoffIndex);
      
      const assetUrl = `{{ 'aa-bulma-critical.css' | asset_url }}`;
      trailingMarkup = `\n<link rel="preload" href="${assetUrl}" as="style">\n<link rel="stylesheet" href="${assetUrl}">\n<noscript><link rel="stylesheet" href="${assetUrl}"></noscript>`;
    }
    
    const content = `{% comment %} Auto-generated by gulpfile.js. Do not edit manually. {% endcomment %}\n<style id="inline-critical-css">${css}</style>${trailingMarkup}\n`;
    
    file.contents = Buffer.from(content);
    file.extname = '.liquid';
    
    cb(null, file);
  });
}

// Build critical CSS
function buildCritical() {
  return src(paths.styles.critical)
    .pipe(sass(sassConfig).on('error', sass.logError))
    .pipe(gulpif(!DISABLE_PURGE, purgecss(purgeConfig)))
    .pipe(rename('aa-bulma-critical.css'))
    .pipe(dest(paths.output.assets))
    .pipe(createInlineSnippet())
    .pipe(rename('inline-critical-css.liquid'))
    .pipe(dest(paths.output.snippets));
}

// Build async CSS
function buildAsync() {
  return src(paths.styles.async)
    .pipe(sass(sassConfig).on('error', sass.logError))
    .pipe(gulpif(!DISABLE_PURGE, purgecss(purgeConfig)))
    .pipe(rename('aa-bulma-async.css'))
    .pipe(dest(paths.output.assets));
}

// Watch task
function watchFiles() {
  console.log('Watching Bulma styles for changes...');
  watch(paths.styles.watch, parallel(buildCritical, buildAsync));
}

// Export tasks
exports.critical = buildCritical;
exports.async = buildAsync;
exports.build = parallel(buildCritical, buildAsync);
exports.watch = series(exports.build, watchFiles);
exports.default = exports.build;